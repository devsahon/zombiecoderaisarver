import { NextResponse } from 'next/server';
import { getDispatcherRules, getActiveProviders, getStorageValue, setStorageValue, addProviderLog } from '@/lib/database';

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const type = searchParams.get('type');

    if (!type) {
      return NextResponse.json(
        { success: false, error: 'Provider type is required' },
        { status: 400 }
      );
    }

    const rules = await getDispatcherRules(type);
    const providers = await getActiveProviders(type);

    return NextResponse.json({
      success: true,
      data: {
        rules,
        providers,
        count: providers.length
      }
    });
  } catch (error) {
    console.error('Dispatcher API error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch dispatcher data' },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  try {
    const { action, input, type, userId, agentId } = await request.json();

    if (!action || !input || !type) {
      return NextResponse.json(
        { success: false, error: 'Action, input, and type are required' },
        { status: 400 }
      );
    }

    switch (action) {
      case 'route_request':
        return await handleRequestRouting(input, type, userId, agentId);
      
      default:
        return NextResponse.json(
          { success: false, error: 'Invalid action' },
          { status: 400 }
        );
    }
  } catch (error) {
    console.error('Dispatcher processing error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to process request' },
      { status: 500 }
    );
  }
}

async function handleRequestRouting(input: string, type: string, userId?: string, agentId?: string) {
  try {
    // Check storage first
    const storageKey = `cache:${type}:${Buffer.from(input).toString('base64')}`;
    const cachedResult = await getStorageValue(storageKey);
    
    if (cachedResult) {
      return NextResponse.json({
        success: true,
        data: {
          result: cachedResult.value,
          source: 'cache',
          provider: 'storage',
          processingTime: 0
        }
      });
    }

    // Get active providers for this type
    const providers = await getActiveProviders(type);
    
    if (providers.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No active providers available for this type' },
        { status: 503 }
      );
    }

    // Try providers in priority order
    for (const provider of providers) {
      try {
        const startTime = Date.now();
        
        // Simulate provider call (replace with actual API calls)
        const result = await callProvider(provider, input);
        const processingTime = Date.now() - startTime;

        // Log successful request
        await addProviderLog(
          provider.id,
          'request',
          input,
          result,
          processingTime,
          'success'
        );

        // Cache the result
        await setStorageValue(storageKey, result, 'cache', userId, agentId, 3600); // 1 hour TTL

        return NextResponse.json({
          success: true,
          data: {
            result,
            source: 'provider',
            provider: provider.name,
            processingTime
          }
        });

      } catch (error) {
        // Log failed request
        await addProviderLog(
          provider.id,
          'request',
          input,
          undefined,
          undefined,
          'error',
          error.message
        );

        // Continue to next provider
        continue;
      }
    }

    // All providers failed
    return NextResponse.json(
      { success: false, error: 'All providers failed to process request' },
      { status: 503 }
    );

  } catch (error) {
    console.error('Request routing error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to route request' },
      { status: 500 }
    );
  }
}

async function callProvider(provider: any, input: string): Promise<string> {
  // Simulate provider API call
  // In production, implement actual API calls based on provider type and configuration
  
  const delay = Math.random() * 2000 + 500; // 500-2500ms delay
  await new Promise(resolve => setTimeout(resolve, delay));

  // Simulate occasional failures
  if (Math.random() < 0.1) { // 10% failure rate
    throw new Error('Provider temporarily unavailable');
  }

  // Return mock response based on provider type
  switch (provider.type) {
    case 'ai':
      return `AI response from ${provider.name}: "${input}" processed successfully.`;
    case 'tts':
      return `TTS audio generated by ${provider.name} for: "${input}"`;
    case 'stt':
      return `STT text from ${provider.name}: "Recognized speech content"`;
    case 'news':
      return `News from ${provider.name}: "Latest news about ${input}"`;
    case 'weather':
      return `Weather from ${provider.name}: "Weather information for ${input}"`;
    default:
      return `Response from ${provider.name}: "${input}" processed.`;
  }
} 